// ============================================
// CORE SERVICES - Fondations de l'app
// Fichier: lib/core/services/
// ============================================

// ============================================
// 1. SUPABASE CLIENT SINGLETON
// Fichier: lib/coeur/services/supabase_service.dart
// ============================================

import 'package:supabase_flutter/supabase_flutter.dart';

class SupabaseService {
  static final SupabaseService _instance = SupabaseService._internal();
  factory SupabaseService() => _instance;
  SupabaseService._internal();

  late final SupabaseClient client;
  
  Future<void> initialize({
    required String url,
    required String anonKey,
  }) async {
    await Supabase.initialize(
      url: url,
      anonKey: anonKey,
      authOptions: const FlutterAuthClientOptions(
        authFlowType: AuthFlowType.pkce, // Sécurisé
      ),
    );
    client = Supabase.instance.client;
  }
  
  // Getters pratiques
  User? get currentUser => client.auth.currentUser;
  String? get userId => currentUser?.id;
  bool get isAuthenticated => currentUser != null;
  
  // Déconnexion
  Future<void> signOut() async {
    await client.auth.signOut();
  }
}

// ============================================
// 2. AUTH SERVICE
// Fichier: lib/core/services/auth_service.dart
// ============================================

import 'package:supabase_flutter/supabase_flutter.dart';

class AuthService {
  final SupabaseClient _supabase;
  
  AuthService(this._supabase);
  
  // Inscription
  Future<AuthResponse> signUp({
    required String email,
    required String password,
    required String nom,
    required String telephone,
    required String adresse,
    required String typeUtilisateur, // Producteur, Transporteur, Acheteur
    Map<String, dynamic>? extraData,
  }) async {
    final response = await _supabase.auth.signUp(
      email: email,
      password: password,
      data: {
        'nom': nom,
        'telephone': telephone,
        'adresse': adresse,
        'type_utilisateur': typeUtilisateur,
        ...?extraData,
      },
    );
    
    if (response.user != null) {
      // Créer l'entrée dans la table utilisateurs
      await _supabase.from('utilisateurs').insert({
        'id': response.user!.id,
        'type_utilisateur': typeUtilisateur,
        'nom': nom,
        'email': email,
        'telephone': telephone,
        'adresse': adresse,
        'mot_de_passe_hashe': 'managed_by_supabase_auth',
      });
      
      // Créer l'entrée dans la table spécifique (producteurs, etc.)
      if (typeUtilisateur == 'Producteur') {
        await _supabase.from('producteurs').insert({
          'id': response.user!.id,
          'anciennete': extraData?['anciennete'] ?? 0,
          'nom_ferme': extraData?['nom_ferme'],
        });
      } else if (typeUtilisateur == 'Transporteur') {
        await _supabase.from('transporteurs').insert({
          'id': response.user!.id,
          'capacite_vehicule': extraData?['capacite_vehicule'] ?? 500,
          'disponibilite': true,
        });
      } else if (typeUtilisateur == 'Acheteur') {
        await _supabase.from('acheteurs').insert({
          'id': response.user!.id,
          'type_activite': extraData?['type_activite'] ?? 'Grossiste',
        });
      }
    }
    
    return response;
  }
  
  // Connexion
  Future<AuthResponse> signIn({
    required String email,
    required String password,
  }) async {
    return await _supabase.auth.signInWithPassword(
      email: email,
      password: password,
    );
  }
  
  // Réinitialisation mot de passe
  Future<void> resetPassword(String email) async {
    await _supabase.auth.resetPasswordForEmail(email);
  }
  
  // Écouter les changements d'état auth
  Stream<AuthState> get authStateChanges => _supabase.auth.onAuthStateChange;
  
  // Obtenir profil complet
  Future<Map<String, dynamic>?> getProfile() async {
    final userId = _supabase.auth.currentUser?.id;
    if (userId == null) return null;
    
    final response = await _supabase
        .from('utilisateurs')
        .select('*, producteurs(*), transporteurs(*), acheteurs(*)')
        .eq('id', userId)
        .single();
    
    return response;
  }
}

// ============================================
// 3. OFFLINE MANAGER (Cache + Queue)
// Fichier: lib/core/services/offline_manager.dart
// ============================================

import 'package:hive_flutter/hive_flutter.dart';
import 'package:connectivity_plus/connectivity_plus.dart';

class OfflineManager {
  static late Box<Map> _cacheBox;
  static late Box<Map> _queueBox;
  
  static Future<void> initialize() async {
    await Hive.initFlutter();
    
    // Box pour cache lecture
    _cacheBox = await Hive.openBox<Map>('data_cache');
    
    // Box pour queue d'actions offline
    _queueBox = await Hive.openBox<Map>('offline_queue');
  }
  
  // Cache - Lecture
  static Future<void> cacheData(String key, Map<String, dynamic> data) async {
    await _cacheBox.put(key, data);
  }
  
  static Map<String, dynamic>? getCachedData(String key) {
    final cached = _cacheBox.get(key);
    return cached != null ? Map<String, dynamic>.from(cached) : null;
  }
  
  static List<Map<String, dynamic>> getCachedList(String key) {
    final cached = _cacheBox.get(key);
    if (cached == null) return [];
    return List<Map<String, dynamic>>.from(
      (cached['items'] as List).map((e) => Map<String, dynamic>.from(e))
    );
  }
  
  // Queue - Écriture offline
  static Future<void> enqueueAction(String action, Map<String, dynamic> data) async {
    final actionId = DateTime.now().millisecondsSinceEpoch.toString();
    await _queueBox.put(actionId, {
      'action': action,
      'data': data,
      'timestamp': DateTime.now().toIso8601String(),
      'attempts': 0,
      'status': 'pending',
    });
  }
  
  static List<Map<String, dynamic>> getPendingActions() {
    return _queueBox.values
        .where((a) => a['status'] == 'pending')
        .map((e) => Map<String, dynamic>.from(e))
        .toList();
  }
  
  static Future<void> markActionSynced(String actionId) async {
    final action = _queueBox.get(actionId);
    if (action != null) {
      action['status'] = 'synced';
      action['synced_at'] = DateTime.now().toIso8601String();
      await _queueBox.put(actionId, action);
    }
  }
  
  static Future<void> clearSyncedActions() async {
    final syncedKeys = _queueBox.keys
        .where((key) => _queueBox.get(key)?['status'] == 'synced')
        .toList();
    for (var key in syncedKeys) {
      await _queueBox.delete(key);
    }
  }
  
  // Connectivité
  static Future<bool> isOnline() async {
    final result = await Connectivity().checkConnectivity();
    return result != ConnectivityResult.none;
  }
  
  static Stream<ConnectivityResult> get connectivityStream =>
      Connectivity().onConnectivityChanged;
}

// ============================================
// 4. NOTIFICATION SERVICE
// Fichier: lib/core/services/notification_service.dart
// ============================================

import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

class NotificationService {
  final FlutterLocalNotificationsPlugin _notifications;
  final SupabaseClient _supabase;
  
  NotificationService(this._supabase)
      : _notifications = FlutterLocalNotificationsPlugin();
  
  Future<void> initialize() async {
    const androidSettings = AndroidInitializationSettings('@mipmap/ic_launcher');
    const iosSettings = DarwinInitializationSettings();
    
    await _notifications.initialize(
      const InitializationSettings(
        android: androidSettings,
        iOS: iosSettings,
      ),
    );
    
    // Écouter les nouvelles notifications en temps réel
    _supabase
        .from('notifications')
        .stream(primaryKey: ['id'])
        .eq('utilisateur_id', _supabase.auth.currentUser?.id ?? '')
        .eq('est_lue', false)
        .listen(_handleNewNotification);
  }
  
  void _handleNewNotification(List<Map<String, dynamic>> data) {
    for (var notif in data) {
      _showLocalNotification(
        id: notif['id'].hashCode,
        title: notif['titre'],
        body: notif['message'],
        urgence: notif['urgence'],
      );
    }
  }
  
  Future<void> _showLocalNotification({
    required int id,
    required String title,
    required String body,
    required String urgence,
  }) async {
    final priority = urgence == 'Critique'
        ? Priority.high
        : urgence == 'Moyen'
            ? Priority.defaultPriority
            : Priority.low;
    
    await _notifications.show(
      id,
      title,
      body,
      NotificationDetails(
        android: AndroidNotificationDetails(
          'agronet_channel',
          'AgroNet Notifications',
          importance: urgence == 'Critique' ? Importance.high : Importance.defaultImportance,
          priority: priority,
        ),
      ),
    );
  }
  
  // Marquer comme lue
  Future<void> markAsRead(String notificationId) async {
    await _supabase
        .from('notifications')
        .update({'est_lue': true})
        .eq('id', notificationId);
  }
  
  // Récupérer notifications non lues
  Future<List<Map<String, dynamic>>> getUnreadNotifications() async {
    return await _supabase
        .from('notifications')
        .select()
        .eq('utilisateur_id', _supabase.auth.currentUser?.id ?? '')
        .eq('est_lue', false)
        .order('date_emission', ascending: false);
  }
}

// ============================================
// 5. QR SERVICE
// Fichier: lib/core/services/qr_service.dart
// ============================================

import 'package:qr_code_scanner/qr_code_scanner.dart';
import 'package:qr_flutter/qr_flutter.dart';
import 'package:flutter/material.dart';

class QRService {
  // Générer QR Code Widget
  static Widget generateQRCode(String data, {double size = 200}) {
    return QrImageView(
      data: data,
      version: QrVersions.auto,
      size: size,
      backgroundColor: Colors.white,
    );
  }
  
  // Scanner QR Code (retourne le widget du scanner)
  static Widget buildQRScanner({
    required Function(String) onScan,
    required Function(String) onError,
  }) {
    return QRScannerWidget(
      onScan: onScan,
      onError: onError,
    );
  }
}

class QRScannerWidget extends StatefulWidget {
  final Function(String) onScan;
  final Function(String) onError;
  
  const QRScannerWidget({
    required this.onScan,
    required this.onError,
    Key? key,
  }) : super(key: key);
  
  @override
  State<QRScannerWidget> createState() => _QRScannerWidgetState();
}

class _QRScannerWidgetState extends State<QRScannerWidget> {
  final GlobalKey qrKey = GlobalKey(debugLabel: 'QR');
  QRViewController? controller;
  
  @override
  void dispose() {
    controller?.dispose();
    super.dispose();
  }
  
  void _onQRViewCreated(QRViewController controller) {
    this.controller = controller;
    controller.scannedDataStream.listen((scanData) {
      if (scanData.code != null) {
        widget.onScan(scanData.code!);
      }
    });
  }
  
  @override
  Widget build(BuildContext context) {
    return QRView(
      key: qrKey,
      onQRViewCreated: _onQRViewCreated,
      overlay: QrScannerOverlayShape(
        borderColor: Colors.green,
        borderRadius: 10,
        borderLength: 30,
        borderWidth: 10,
        cutOutSize: 300,
      ),
    );
  }
}

// ============================================
// 6. LOCATION SERVICE (GPS)
// Fichier: lib/core/services/location_service.dart
// ============================================

import 'package:geolocator/geolocator.dart';

class LocationService {
  // Vérifier permissions
  static Future<bool> checkPermissions() async {
    LocationPermission permission = await Geolocator.checkPermission();
    
    if (permission == LocationPermission.denied) {
      permission = await Geolocator.requestPermission();
    }
    
    return permission == LocationPermission.always ||
           permission == LocationPermission.whileInUse;
  }
  
  // Obtenir position actuelle
  static Future<Position?> getCurrentPosition() async {
    if (!await checkPermissions()) return null;
    
    return await Geolocator.getCurrentPosition(
      desiredAccuracy: LocationAccuracy.high,
    );
  }
  
  // Écouter position en temps réel (pour transporteurs)
  static Stream<Position> getPositionStream() {
    return Geolocator.getPositionStream(
      locationSettings: const LocationSettings(
        accuracy: LocationAccuracy.high,
        distanceFilter: 10, // Mise à jour tous les 10m
      ),
    );
  }
  
  // Calculer distance entre 2 points
  static double calculateDistance(
    double lat1, double lon1,
    double lat2, double lon2,
  ) {
    return Geolocator.distanceBetween(lat1, lon1, lat2, lon2) / 1000; // en km
  }
}



// ============================================
// WIDGETS RÉUTILISABLES
// Fichier: lib/shared/widgets/
// ============================================

import 'package:flutter/material.dart';

// ============================================
// 1. CUSTOM APP BAR
// Fichier: lib/shared/widgets/custom_app_bar.dart
// ============================================

class CustomAppBar extends StatelessWidget implements PreferredSizeWidget {
  final String title;
  final List<Widget>? actions;
  final Widget? leading;
  final bool showBackButton;
  
  const CustomAppBar({
    required this.title,
    this.actions,
    this.leading,
    this.showBackButton = true,
    Key? key,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return AppBar(
      title: Text(title),
      backgroundColor: const Color(0xFF2E7D32), // Vert émeraude
      foregroundColor: Colors.white,
      elevation: 2,
      centerTitle: true,
      leading: leading ?? (showBackButton ? null : const SizedBox()),
      actions: actions,
    );
  }
  
  @override
  Size get preferredSize => const Size.fromHeight(kToolbarHeight);
}

// ============================================
// 2. LOADING OVERLAY
// Fichier: lib/shared/widgets/loading_overlay.dart
// ============================================

class LoadingOverlay extends StatelessWidget {
  final bool isLoading;
  final Widget child;
  final String? message;
  
  const LoadingOverlay({
    required this.isLoading,
    required this.child,
    this.message,
    Key? key,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return Stack(
      children: [
        child,
        if (isLoading)
          Container(
            color: Colors.black54,
            child: Center(
              child: Card(
                child: Padding(
                  padding: const EdgeInsets.all(24),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      const CircularProgressIndicator(),
                      if (message != null) ...[
                        const SizedBox(height: 16),
                        Text(
                          message!,
                          style: const TextStyle(fontSize: 16),
                        ),
                      ],
                    ],
                  ),
                ),
              ),
            ),
          ),
      ],
    );
  }
}

// ============================================
// 3. EMPTY STATE
// Fichier: lib/shared/widgets/empty_state.dart
// ============================================

class EmptyState extends StatelessWidget {
  final IconData icon;
  final String title;
  final String message;
  final VoidCallback? onAction;
  final String? actionLabel;
  
  const EmptyState({
    required this.icon,
    required this.title,
    required this.message,
    this.onAction,
    this.actionLabel,
    Key? key,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(32),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              icon,
              size: 80,
              color: Colors.grey[400],
            ),
            const SizedBox(height: 16),
            Text(
              title,
              style: const TextStyle(
                fontSize: 20,
                fontWeight: FontWeight.bold,
                color: Colors.black87,
              ),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 8),
            Text(
              message,
              style: TextStyle(
                fontSize: 16,
                color: Colors.grey[600],
              ),
              textAlign: TextAlign.center,
            ),
            if (onAction != null) ...[
              const SizedBox(height: 24),
              ElevatedButton.icon(
                onPressed: onAction,
                icon: const Icon(Icons.add),
                label: Text(actionLabel ?? 'Ajouter'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: const Color(0xFF2E7D32),
                  padding: const EdgeInsets.symmetric(
                    horizontal: 24,
                    vertical: 12,
                  ),
                ),
              ),
            ],
          ],
        ),
      ),
    );
  }
}

// ============================================
// 4. ERROR STATE
// Fichier: lib/shared/widgets/error_state.dart
// ============================================

class ErrorState extends StatelessWidget {
  final String message;
  final VoidCallback onRetry;
  
  const ErrorState({
    required this.message,
    required this.onRetry,
    Key? key,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(32),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(
              Icons.error_outline,
              size: 80,
              color: Colors.red,
            ),
            const SizedBox(height: 16),
            const Text(
              'Erreur',
              style: TextStyle(
                fontSize: 20,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              message,
              style: const TextStyle(fontSize: 16),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 24),
            ElevatedButton.icon(
              onPressed: onRetry,
              icon: const Icon(Icons.refresh),
              label: const Text('Réessayer'),
            ),
          ],
        ),
      ),
    );
  }
}

// ============================================
// 5. CUSTOM CARD
// Fichier: lib/shared/widgets/custom_card.dart
// ============================================

class CustomCard extends StatelessWidget {
  final Widget child;
  final EdgeInsets? padding;
  final VoidCallback? onTap;
  final Color? color;
  
  const CustomCard({
    required this.child,
    this.padding,
    this.onTap,
    this.color,
    Key? key,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return Card(
      color: color,
      elevation: 2,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(12),
      ),
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(12),
        child: Padding(
          padding: padding ?? const EdgeInsets.all(16),
          child: child,
        ),
      ),
    );
  }
}

// ============================================
// 6. BADGE WIDGET (Promo, Alerte, etc.)
// Fichier: lib/shared/widgets/badge_widget.dart
// ============================================

class BadgeWidget extends StatelessWidget {
  final String text;
  final Color color;
  final IconData? icon;
  
  const BadgeWidget({
    required this.text,
    required this.color,
    this.icon,
    Key? key,
  }) : super(key: key);
  
  // Badges pré-définis
  factory BadgeWidget.promo(String text) {
    return BadgeWidget(
      text: text,
      color: Colors.orange,
      icon: Icons.local_fire_department,
    );
  }
  
  factory BadgeWidget.alerte() {
    return const BadgeWidget(
      text: 'Critique',
      color: Colors.red,
      icon: Icons.warning,
    );
  }
  
  factory BadgeWidget.frais() {
    return const BadgeWidget(
      text: 'Frais',
      color: Colors.green,
      icon: Icons.check_circle,
    );
  }
  
  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
      decoration: BoxDecoration(
        color: color.withOpacity(0.2),
        borderRadius: BorderRadius.circular(20),
        border: Border.all(color: color, width: 1.5),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          if (icon != null) ...[
            Icon(icon, size: 16, color: color),
            const SizedBox(width: 4),
          ],
          Text(
            text,
            style: TextStyle(
              color: color,
              fontWeight: FontWeight.bold,
              fontSize: 12,
            ),
          ),
        ],
      ),
    );
  }
}

// ============================================
// 7. CUSTOM TEXT FIELD
// Fichier: lib/shared/widgets/custom_text_field.dart
// ============================================

class CustomTextField extends StatelessWidget {
  final TextEditingController controller;
  final String label;
  final String? hint;
  final IconData? prefixIcon;
  final bool obscureText;
  final TextInputType? keyboardType;
  final String? Function(String?)? validator;
  final int? maxLines;
  final bool enabled;
  
  const CustomTextField({
    required this.controller,
    required this.label,
    this.hint,
    this.prefixIcon,
    this.obscureText = false,
    this.keyboardType,
    this.validator,
    this.maxLines = 1,
    this.enabled = true,
    Key? key,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return TextFormField(
      controller: controller,
      obscureText: obscureText,
      keyboardType: keyboardType,
      validator: validator,
      maxLines: maxLines,
      enabled: enabled,
      decoration: InputDecoration(
        labelText: label,
        hintText: hint,
        prefixIcon: prefixIcon != null ? Icon(prefixIcon) : null,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide(color: Colors.grey[300]!),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: Color(0xFF2E7D32), width: 2),
        ),
        filled: true,
        fillColor: enabled ? Colors.white : Colors.grey[100],
      ),
    );
  }
}

// ============================================
// 8. CUSTOM DROPDOWN
// Fichier: lib/shared/widgets/custom_dropdown.dart
// ============================================

class CustomDropdown<T> extends StatelessWidget {
  final T? value;
  final List<DropdownMenuItem<T>> items;
  final void Function(T?) onChanged;
  final String label;
  final IconData? prefixIcon;
  
  const CustomDropdown({
    required this.value,
    required this.items,
    required this.onChanged,
    required this.label,
    this.prefixIcon,
    Key? key,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return DropdownButtonFormField<T>(
      value: value,
      items: items,
      onChanged: onChanged,
      decoration: InputDecoration(
        labelText: label,
        prefixIcon: prefixIcon != null ? Icon(prefixIcon) : null,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
        ),
        filled: true,
        fillColor: Colors.white,
      ),
    );
  }
}

// ============================================
// 9. OFFLINE INDICATOR
// Fichier: lib/shared/widgets/offline_indicator.dart
// ============================================

class OfflineIndicator extends StatelessWidget {
  final int actionsEnAttente;
  final VoidCallback onSync;
  final bool isSyncing;
  
  const OfflineIndicator({
    required this.actionsEnAttente,
    required this.onSync,
    this.isSyncing = false,
    Key? key,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    if (actionsEnAttente == 0) return const SizedBox.shrink();
    
    return Container(
      color: Colors.orange[100],
      padding: const EdgeInsets.all(12),
      child: Row(
        children: [
          const Icon(Icons.cloud_off, color: Colors.orange),
          const SizedBox(width: 8),
          Expanded(
            child: Text(
              '$actionsEnAttente action(s) en attente de synchronisation',
              style: TextStyle(color: Colors.orange[900]),
            ),
          ),
          if (isSyncing)
            const SizedBox(
              width: 20,
              height: 20,
              child: CircularProgressIndicator(strokeWidth: 2),
            )
          else
            TextButton(
              onPressed: onSync,
              child: const Text('Synchroniser'),
            ),
        ],
      ),
    );
  }
}

// ============================================
// 10. STAT CARD (Dashboard)
// Fichier: lib/shared/widgets/stat_card.dart
// ============================================

class StatCard extends StatelessWidget {
  final String title;
  final String value;
  final IconData icon;
  final Color color;
  final VoidCallback? onTap;
  
  const StatCard({
    required this.title,
    required this.value,
    required this.icon,
    required this.color,
    this.onTap,
    Key? key,
  }) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return CustomCard(
      onTap: onTap,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceBetween,
            children: [
              Icon(icon, color: color, size: 32),
              Container(
                padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
                decoration: BoxDecoration(
                  color: color.withOpacity(0.2),
                  borderRadius: BorderRadius.circular(8),
                ),
                child: Text(
                  value,
                  style: TextStyle(
                    fontSize: 20,
                    fontWeight: FontWeight.bold,
                    color: color,
                  ),
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          Text(
            title,
            style: const TextStyle(
              fontSize: 14,
              color: Colors.black87,
            ),
          ),
        ],
      ),
    );
  }
}


// ============================================
// UTILS & HELPERS
// Fichier: lib/core/utils/
// ============================================

// ============================================
// 1. CONSTANTS
// Fichier: lib/core/utils/constants.dart
// ============================================

class AppConstants {
  // Supabase
  static const String supabaseUrl = 'YOUR_SUPABASE_URL';
  static const String supabaseAnonKey = 'YOUR_SUPABASE_ANON_KEY';
  
  // Thème
  static const Color primaryColor = Color(0xFF2E7D32); // Vert émeraude
  static const Color secondaryColor = Color(0xFF1976D2); // Bleu horizon
  static const Color accentColor = Color(0xFFFF6F00); // Orange ambre
  static const Color darkColor = Color(0xFF212121); // Noir profond
  
  // Statuts
  static const Map<String, Color> statutColors = {
    'Frais': Color(0xFF4CAF50),
    'Critique': Color(0xFFFF9800),
    'Perime': Color(0xFFF44336),
    'Brouillon': Color(0xFF9E9E9E),
    'Validee': Color(0xFF2196F3),
    'EnLivraison': Color(0xFFFF9800),
    'Livree': Color(0xFF4CAF50),
    'Cloturee': Color(0xFF4CAF50),
  };
  
  // Messages
  static const String errorGeneric = 'Une erreur s\'est produite';
  static const String errorNetwork = 'Erreur réseau. Vérifiez votre connexion';
  static const String successSaved = 'Enregistré avec succès';
}

// ============================================
// 2. FORMATTERS
// Fichier: lib/core/utils/formatters.dart
// ============================================

import 'package:intl/intl.dart';

class Formatters {
  // Format date
  static String formatDate(DateTime date) {
    return DateFormat('dd/MM/yyyy').format(date);
  }
  
  static String formatDateTime(DateTime date) {
    return DateFormat('dd/MM/yyyy à HH:mm').format(date);
  }
  
  static String formatTime(DateTime date) {
    return DateFormat('HH:mm').format(date);
  }
  
  // Format montant
  static String formatMontant(double montant) {
    return NumberFormat('#,##0', 'fr_FR').format(montant) + ' FCFA';
  }
  
  // Format quantité
  static String formatQuantite(double quantite) {
    return NumberFormat('#,##0.##', 'fr_FR').format(quantite) + ' kg';
  }
  
  // Temps relatif
  static String formatTimeAgo(DateTime date) {
    final now = DateTime.now();
    final difference = now.difference(date);
    
    if (difference.inDays > 365) {
      return 'Il y a ${(difference.inDays / 365).floor()} an(s)';
    } else if (difference.inDays > 30) {
      return 'Il y a ${(difference.inDays / 30).floor()} mois';
    } else if (difference.inDays > 0) {
      return 'Il y a ${difference.inDays} jour(s)';
    } else if (difference.inHours > 0) {
      return 'Il y a ${difference.inHours} heure(s)';
    } else if (difference.inMinutes > 0) {
      return 'Il y a ${difference.inMinutes} minute(s)';
    } else {
      return 'À l\'instant';
    }
  }
}

// ============================================
// 3. VALIDATORS
// Fichier: lib/core/utils/validators.dart
// ============================================

class Validators {
  // Email
  static String? email(String? value) {
    if (value == null || value.isEmpty) {
      return 'Email requis';
    }
    final emailRegex = RegExp(r'^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$');
    if (!emailRegex.hasMatch(value)) {
      return 'Email invalide';
    }
    return null;
  }
  
  // Mot de passe
  static String? password(String? value) {
    if (value == null || value.isEmpty) {
      return 'Mot de passe requis';
    }
    if (value.length < 6) {
      return 'Minimum 6 caractères';
    }
    return null;
  }
  
  // Téléphone togolais
  static String? telephone(String? value) {
    if (value == null || value.isEmpty) {
      return 'Téléphone requis';
    }
    final phoneRegex = RegExp(r'^\+228\d{8}$');
    if (!phoneRegex.hasMatch(value)) {
      return 'Format: +228XXXXXXXX';
    }
    return null;
  }
  
  // Requis
  static String? required(String? value, {String field = 'Ce champ'}) {
    if (value == null || value.isEmpty) {
      return '$field est requis';
    }
    return null;
  }
  
  // Nombre positif
  static String? positiveNumber(String? value) {
    if (value == null || value.isEmpty) {
      return 'Valeur requise';
    }
    final number = double.tryParse(value);
    if (number == null || number <= 0) {
      return 'Doit être un nombre positif';
    }
    return null;
  }
}

// ============================================
// 4. SNACKBAR HELPER
// Fichier: lib/core/utils/snackbar_helper.dart
// ============================================

import 'package:flutter/material.dart';

class SnackbarHelper {
  static void showSuccess(BuildContext context, String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Row(
          children: [
            const Icon(Icons.check_circle, color: Colors.white),
            const SizedBox(width: 12),
            Expanded(child: Text(message)),
          ],
        ),
        backgroundColor: Colors.green,
        behavior: SnackBarBehavior.floating,
        duration: const Duration(seconds: 3),
      ),
    );
  }
  
  static void showError(BuildContext context, String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Row(
          children: [
            const Icon(Icons.error, color: Colors.white),
            const SizedBox(width: 12),
            Expanded(child: Text(message)),
          ],
        ),
        backgroundColor: Colors.red,
        behavior: SnackBarBehavior.floating,
        duration: const Duration(seconds: 4),
      ),
    );
  }
  
  static void showInfo(BuildContext context, String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Row(
          children: [
            const Icon(Icons.info, color: Colors.white),
            const SizedBox(width: 12),
            Expanded(child: Text(message)),
          ],
        ),
        backgroundColor: Colors.blue,
        behavior: SnackBarBehavior.floating,
        duration: const Duration(seconds: 3),
      ),
    );
  }
}

// ============================================
// 5. DIALOG HELPER
// Fichier: lib/core/utils/dialog_helper.dart
// ============================================

import 'package:flutter/material.dart';

class DialogHelper {
  // Confirmation dialog
  static Future<bool> showConfirmation(
    BuildContext context, {
    required String title,
    required String message,
    String confirmText = 'Confirmer',
    String cancelText = 'Annuler',
  }) async {
    final result = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(title),
        content: Text(message),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: Text(cancelText),
          ),
          ElevatedButton(
            onPressed: () => Navigator.of(context).pop(true),
            child: Text(confirmText),
          ),
        ],
      ),
    );
    return result ?? false;
  }
  
  // Loading dialog
  static void showLoading(BuildContext context, {String? message}) {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => WillPopScope(
        onWillPop: () async => false,
        child: AlertDialog(
          content: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const CircularProgressIndicator(),
              if (message != null) ...[
                const SizedBox(height: 16),
                Text(message),
              ],
            ],
          ),
        ),
      ),
    );
  }
  
  static void hideLoading(BuildContext context) {
    Navigator.of(context).pop();
  }
}

// ============================================
// 6. MAIN.DART - Configuration complète
// Fichier: lib/main.dart
// ============================================

import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  
  // 1. Initialiser Hive (cache offline)
  await OfflineManager.initialize();
  
  // 2. Initialiser Supabase
  await SupabaseService().initialize(
    url: AppConstants.supabaseUrl,
    anonKey: AppConstants.supabaseAnonKey,
  );
  
  // 3. Synchroniser actions offline au démarrage
  try {
    await syncOfflineActions();
  } catch (e) {
    print('Synchronisation initiale échouée: $e');
  }
  
  runApp(const MyApp());
}

// Fonction de synchronisation globale
Future<void> syncOfflineActions() async {
  if (!await OfflineManager.isOnline()) return;
  
  final pendingActions = OfflineManager.getPendingActions();
  for (var action in pendingActions) {
    try {
      await executeOfflineAction(action);
      await OfflineManager.markActionSynced(action['id']);
    } catch (e) {
      print('Erreur sync action ${action['action']}: $e');
    }
  }
}

Future<void> executeOfflineAction(Map<String, dynamic> action) async {
  final supabase = SupabaseService().client;
  
  switch (action['action']) {
    case 'declarer_recolte':
      await supabase.from('lots').insert(action['data']);
      break;
    case 'creer_commande':
      await supabase.rpc('creer_commande', params: action['data']);
      break;
    // Ajouter d'autres actions...
  }
}

class MyApp extends StatelessWidget {
  const MyApp({Key? key}) : super(key: key);
  
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'AgroNet',
      debugShowCheckedModeBanner: false,
      
      // Thème
      theme: ThemeData(
        primaryColor: AppConstants.primaryColor,
        colorScheme: ColorScheme.fromSeed(
          seedColor: AppConstants.primaryColor,
          brightness: Brightness.light,
        ),
        useMaterial3: true,
        fontFamily: 'Roboto',
        
        // App Bar Theme
        appBarTheme: const AppBarTheme(
          backgroundColor: AppConstants.primaryColor,
          foregroundColor: Colors.white,
          elevation: 2,
          centerTitle: true,
        ),
        
        // Input Decoration Theme
        inputDecorationTheme: InputDecorationTheme(
          filled: true,
          fillColor: Colors.white,
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(12),
          ),
          contentPadding: const EdgeInsets.symmetric(
            horizontal: 16,
            vertical: 16,
          ),
        ),
        
        // Elevated Button Theme
        elevatedButtonTheme: ElevatedButtonThemeData(
          style: ElevatedButton.styleFrom(
            backgroundColor: AppConstants.primaryColor,
            foregroundColor: Colors.white,
            padding: const EdgeInsets.symmetric(
              horizontal: 24,
              vertical: 12,
            ),
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(12),
            ),
          ),
        ),
        
        // Card Theme
        cardTheme: CardTheme(
          elevation: 2,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
          ),
        ),
      ),
      
      // Localizations
      localizationsDelegates: const [
        GlobalMaterialLocalizations.delegate,
        GlobalWidgetsLocalizations.delegate,
        GlobalCupertinoLocalizations.delegate,
      ],
      supportedLocales: const [
        Locale('fr', 'FR'),
      ],
      locale: const Locale('fr', 'FR'),
      
      // Routes
      initialRoute: '/splash',
      routes: {
        '/splash': (context) => const SplashScreen(),
        '/login': (context) => const LoginScreen(),
        '/register': (context) => const RegisterScreen(),
        '/producteur': (context) => const ProducteurHomeScreen(),
        '/acheteur': (context) => const AcheteurHomeScreen(),
        '/transporteur': (context) => const TransporteurHomeScreen(),
        '/admin': (context) => const AdminHomeScreen(),
      },
    );
  }
}

// ============================================
// 7. SPLASH SCREEN
// Fichier: lib/screens/splash_screen.dart
// ============================================

class SplashScreen extends StatefulWidget {
  const SplashScreen({Key? key}) : super(key: key);
  
  @override
  State<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends State<SplashScreen> {
  @override
  void initState() {
    super.initState();
    _checkAuth();
  }
  
  Future<void> _checkAuth() async {
    await Future.delayed(const Duration(seconds: 2));
    
    final supabase = SupabaseService();
    
    if (supabase.isAuthenticated) {
      // Récupérer le type d'utilisateur
      final profile = await AuthService(supabase.client).getProfile();
      final typeUtilisateur = profile?['type_utilisateur'];
      
      // Rediriger selon le rôle
      switch (typeUtilisateur) {
        case 'Producteur':
          Navigator.of(context).pushReplacementNamed('/producteur');
          break;
        case 'Acheteur':
          Navigator.of(context).pushReplacementNamed('/acheteur');
          break;
        case 'Transporteur':
          Navigator.of(context).pushReplacementNamed('/transporteur');
          break;
        case 'Admin':
          Navigator.of(context).pushReplacementNamed('/admin');
          break;
        default:
          Navigator.of(context).pushReplacementNamed('/login');
      }
    } else {
      Navigator.of(context).pushReplacementNamed('/login');
    }
  }
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: AppConstants.primaryColor,
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            // Logo
            Container(
              width: 150,
              height: 150,
              decoration: BoxDecoration(
                color: Colors.white,
                borderRadius: BorderRadius.circular(20),
              ),
              child: const Icon(
                Icons.agriculture,
                size: 100,
                color: AppConstants.primaryColor,
              ),
            ),
            const SizedBox(height: 24),
            const Text(
              'AgroNet',
              style: TextStyle(
                fontSize: 36,
                fontWeight: FontWeight.bold,
                color: Colors.white,
              ),
            ),
            const SizedBox(height: 8),
            const Text(
              'Traçabilité Intelligente',
              style: TextStyle(
                fontSize: 16,
                color: Colors.white70,
              ),
            ),
            const SizedBox(height: 48),
            const CircularProgressIndicator(
              color: Colors.white,
            ),
          ],
        ),
      ),
    );
  }
}


lib/
├── main.dart
├── core/
│   ├── services/
│   │   ├── supabase_service.dart
│   │   ├── auth_service.dart
│   │   ├── offline_manager.dart
│   │   ├── notification_service.dart
│   │   ├── qr_service.dart
│   │   └── location_service.dart
│   ├── utils/
│   │   ├── constants.dart
│   │   ├── formatters.dart
│   │   ├── validators.dart
│   │   ├── snackbar_helper.dart
│   │   └── dialog_helper.dart
│   └── models/
│       ├── utilisateur.dart
│       ├── produit.dart
│       ├── lot.dart
│       ├── commande.dart
│       └── livraison.dart
├── shared/
│   └── widgets/
│       ├── custom_app_bar.dart
│       ├── loading_overlay.dart
│       ├── empty_state.dart
│       ├── error_state.dart
│       ├── custom_card.dart
│       ├── badge_widget.dart
│       ├── custom_text_field.dart
│       ├── custom_dropdown.dart
│       ├── offline_indicator.dart
│       └── stat_card.dart
├── features/
│   ├── auth/
│   │   ├── screens/
│   │   │   ├── login_screen.dart
│   │   │   └── register_screen.dart
│   │   ├── widgets/
│   │   └── bloc/
│   ├── producteur/
│   │   ├── screens/
│   │   │   ├── producteur_home_screen.dart
│   │   │   ├── declarer_recolte_screen.dart
│   │   │   ├── mes_stocks_screen.dart
│   │   │   └── qr_viewer_screen.dart
│   │   ├── widgets/
│   │   └── bloc/
│   ├── acheteur/
│   │   ├── screens/
│   │   │   ├── acheteur_home_screen.dart
│   │   │   ├── marketplace_screen.dart
│   │   │   ├── panier_screen.dart
│   │   │   └── mes_commandes_screen.dart
│   │   ├── widgets/
│   │   └── bloc/
│   ├── transporteur/
│   │   ├── screens/
│   │   │   ├── transporteur_home_screen.dart
│   │   │   ├── livraisons_disponibles_screen.dart
│   │   │   └── mes_livraisons_screen.dart
│   │   ├── widgets/
│   │   └── bloc/
│   └── admin/
│       ├── screens/
│       │   ├── admin_home_screen.dart
│       │   ├── validation_utilisateurs_screen.dart
│       │   └── gestion_produits_screen.dart
│       ├── widgets/
│       └── bloc/
└── screens/
    └── splash_screen.dart